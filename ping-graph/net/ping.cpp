/*
Module : PING.CPP
Purpose: Implementation for an MFC wrapper class to encapsulate PING
Created: PJN / 10-06-1998
History: PJN / 23-06-1998 1. Now code can be compiled to use Winsock2 calls
                          instead of using the ICMP.DLL. This gives another of
                          advantages:
                            i.  Your using a API that MS has promised to continue to support.
                            ii. Internally the class calls QueryPerformanceCounter meaning that
                                you will get the highest resolution RTT's possible.
                          2. Also did a general tidy up of the code
                          3. Changed default timeout to 1 second
         PJN / 30-07-1998 1. Can now use both Winsock 2 calls and ICMP style
                          calls at the same time with the use of 2 preprocessor directives
                          2. sample program now use generic entry point _tmain 
                          3. Got rid of a 2 level 4 compiler warning
                          4. Fixed a problem with the cleanup of ICMP dll usage
                          5. Tidied up and optimized the usage of static variables
         PJN / 01-03-2000 1. Fixed a problem where I was incorrectly overwritting memory in          
                          the function FillIcmpData  
         PJN / 15-07-2001 1. Updated copyright information
                          2. Code now automatically pulls in the Winsock 2 libraries as and when needed
         PJN / 12-01-2002 1. Updated copyright information
                          2. Now initializes Winsock 2.0 instead of Winsock 2.1. Thanks to Lev Elbert
                          for spotting this problem.
         PJN / 24-02-2002 1. Winsock 2 code path now allows you to bind the socket to a specific NIC.
                          This can prove useful when you want to run a targeted ping request on a
                          mulithoned machine.
                          2. Tidied up the code in the sample application
                          3. Provide a complete set of command line options for the sample app. It
                          now provides almost a 1 - 1 implementation of the build in Ping options.
                          4. Completed reworked and recoded all the CPing code.
                          5. Client code is now responsible for initializing Winsock instead of 
                          having it embedded in the CPing code
         PJN / 05-05-2002 1. Now includes a EchoReplyStatus in CPingReply structure if CPING_NO_ICMP is not 
                          defined
         PJN / 21-11-2002 1. Fixed an issue in the calculation of the packet size when sending using 
                          raw sockets.
                          2. Default sample now uses a default TTL of 30
                          3. Changes the nPacketSize parameter to the Ping method to be nDataSize which is 
                          what it really is.
                          4. Reviewed all the TRACE messages for correctness
                          5. Made all the helper functions used by the code member functions of the class
                          6. General tidy up of the various defines
                          7. Winsock 2 version of ping now allows you to specify the sequence number of the 
                          packet. This allows the ping to exclude packets from the same process id which
                          are being generated by for example another thread.
                          8. Fixed a bug in the call to recvfrom. The receive buffer size was not being
                          specified correctly.
                          9. ICMP response packets from other processes are now ignored when waiting for 
                          an ICMP response
                          10. ICMP response packets from the same process but which have an incorrect 
                          sequence number are now ignored when waiting for an ICMP response.
                          11. Fix a resource leak of a socket when unexpected failures occur in the 
                          CPing::PingUsingWinsock function
         PJN / 10-03-2003 1. Fixed a bug where using PingUsingWinsock and setting the data size greater 
                          than 1004 appears to cause Winsock error 10040 - The datagram is too large to 
                          fit into the buffer and is truncated. Thanks to Paul Golightly for reported this
                          and provided the fix.
         PJN / 13-03-2003 1. Fixed a bug in CPing::IsSocketReadible in the setup of the timeval structure. 
                          Thanks to "InBloom Support" for reporting this.
         PJN / 23-11-2003 1. Fixed a level 4 warning in VC 6 in the function CPing::PingUsingWinsock.
         PJN / 12-04-2004 1. Fixed a bug in the declaration of h_len and version in the IP_HEADER structure. 
                          Also made the source and destination IP addresses longs instead of ints to avoid
                          any porting problems. Thanks to Yuh-Rong Leu for reporting this problem. 
                          2. Fixed a bug in PingUsingWinsock when a timeout occurs and it returns TRUE. 
                          Thanks to Yuh-Rong Leu for reporting this problem.
                          3. Updated the documentation to refer to using the value from GetCurrentThreadId()
                          for the nSequenceNumber parameter when calling the PingUsingWinsock function.
                          Again thanks to Yuh-Rong Leu for reporting this issue.
                          4. Fixed an issue in DecodeResponse where if bTryAgain was set to TRUE, the return
                          value was incorrectly also being set to TRUE. Thanks to Yuh-Rong Leu for reporting 
                          this issue. 
         PJN / 11-06-2005 1. Reviewed all TRACE statements for correctness. Thanks to "Grenal" for reporting
                          this issue.
                          2. Checked all premature return points in the codebase to ensure the last error 
                          value is preserved.
                          3. Fixed an unreferrenced variable in DecodeResponse function when code is compiled
                          with Visual Studio .NET 2003
         PJN / 31-07-2005 1. When sending a ping, the allowable size of the data in the packet 
                          can now be anywhere from 0 to 65500. Previosuly sending a ping using Winsock was
                          limited to a data size of 1024 and when using ICMP.dll, the size was limited to 255.
                          Thanks to Leon Luu for reporting this issue.
         PJN / 31-07-2005 1. Now the PingUsingICMP method using the versions provided in the IP Helper dll
                          namely "Iphlpapi.dll" before falling back to "ICMP.dll".
                          2. Tidied up the various ICMP defines by making them part of the _CPING_ICMP class
         PJN / 10-07-2006 1. Updated copyright details
                          2. The code now requires the Platform SDK if compiled using VC 6.
                          3. Integrated the functionality of _CPING_ICMP class into CPing
                          4. Optimized CPingReply constructor code
                          5. Code now uses newer C++ style casts instead of C style casts.
                          6. Addition of CPING_EXT_CLASS macro to allow the code to be easily added to an 
                          extension dll.
                          7. Code now uses newer C++ style casts instead of C style casts.
                          8. Updated the code to clean compile on VC 2005.
                          9. Updated documentation to use the same style as the web site.
         PJN / 03-10-2007 1. Updated copyright details. 
                          2. Fixed small layout problem in sample app when it displays it could not ping
                          the specified host.
                          3. Updated the sample app to compile cleanly in VC 2005
         PJN / 07-06-2008 1. Updated copyright details
                          2. Updated the sample app to clean compile on VC 2008
                          3. Code now compiles cleanly using Code Analysis (/analyze)
                          4. The code has now been updated to support VC 2005 or later only
                          5. Replaced all calls to ZeroMemory with memset
                          6. Code now uses ATL::CHeapPtr for managed raw buffers
                          7. The "Bind", "FillIcmpData", "DecodeResponse" and "GenerateIPChecksum" methods
                          have been made virtual. This for example allows client code to decide what data
                          gets put into ICMP request packets. Thanks to Dinci Glas for prompting this 
                          update.
         PJN / 02-05-2016 1. Updated copyright details.
                          2. Updated the sample project settings to more modern default values.
                          3. Updated the code to compile cleanly on VC 2010 - 2015.
                          4. Replaced all calls to TRACE with ATLTRACE
                          5. Code no longer uses LoadLibrary without an absolute path when loading Iphlpapi / ICMP
                          dlls. This avoids DLL planting security issues.
                          6. Removed code from CPing::DecodeResponse which checks i_type & i_id header values.
                          7. Made class MFC independent. Now the code only depends on ATL.
                          8. Removed code from CPing::PingUsingICMP which parses the response.
                          9. Added support for IPv6 in addition to IPv4. This means that the minimum supported
                          version of VC which supports CPing is now VC 2008. The sample now ships with a VC 2008
                          solution.
                          10. Code now supports IcmpSendEcho2Ex which supports IPv4 source address binding
                          11. Removed the PingUsingWinsock method from the class as all the ping functionality
                          can now be achieved via the Icmp* Windows API calls. This means that the CPING_NO_ICMP
                          and CPING_NO_WINSOCK2 preprocessor values are defunct and have been removed.
                          12. Added SAL annotations to all the code.
                          13. Added support for the IP_FLAG_REVERSE IP_OPTION_INFORMATION flag.
                          14. Addition of GetICMP_ECHO_REPLY and GetICMPV6_ECHO_REPLY methods to the CPingReply
                          class which allow access to the raw ICMP echo reply structure.
         PJN / 06-05-2016 1. Split CPingReply class into two separate CPingReplyv4 and CPingReplyv6 classes.

Copyright (c) 1998 - 2016 by PJ Naughter (Web: www.naughter.com, Email: pjna@naughter.com)

All rights reserved.

Copyright / Usage Details:

You are allowed to include the source code in any product (commercial, shareware, freeware or otherwise) 
when your product is released in binary form. You are allowed to modify the source code in any way you want 
except you cannot modify the copyright details at the top of each module. If you want to distribute source 
code with your application, then you are only allowed to distribute versions released by the author. This is 
to maintain a single distribution point for the source code. 

http://www.naughter.com/ping.html
*/


///////////////////////////////// Includes ////////////////////////////////////

#include "ping.h"


///////////////////////////////// Implementation //////////////////////////////

CPingReplyv4::CPingReplyv4() : RTT(0),
                               EchoReplyStatus(0)
{
  memset(&Address, 0, sizeof(Address));
}

const ICMP_ECHO_REPLY* CPingReplyv4::GetICMP_ECHO_REPLY()
{
  const ICMP_ECHO_REPLY* pEchoReply = reinterpret_cast<ICMP_ECHO_REPLY*>(Reply.m_pData);
  return pEchoReply;
}


CPingReplyv6::CPingReplyv6() : RTT(0),
                               EchoReplyStatus(0)
{
  memset(&Address, 0, sizeof(Address));
}

const ICMPV6_ECHO_REPLY* CPingReplyv6::GetICMPV6_ECHO_REPLY()
{
  const ICMPV6_ECHO_REPLY* pEchoReply = reinterpret_cast<ICMPV6_ECHO_REPLY*>(Reply.m_pData);
  return pEchoReply;
}


CPing::CPing() : m_hIcmp(NULL),
                 m_pIcmpCreateFile(NULL),
                 m_pIcmp6CreateFile(NULL),
                 m_pIcmpSendEcho(NULL),
                 m_pIcmp6SendEcho2(NULL),
                 m_pIcmpSendEcho2Ex(NULL),
                 m_pIcmpCloseHandle(NULL)
{
  //First try the IP Helper library
  m_hIcmp = LoadLibraryFromSystem32(_T("Iphlpapi.dll"));
  if (m_hIcmp != NULL)
  {
    //Retrieve pointers to the functions in the ICMP dll
    m_pIcmpCreateFile = reinterpret_cast<LPICMPCREATEFILE>(GetProcAddress(m_hIcmp, "IcmpCreateFile"));
    m_pIcmp6CreateFile = reinterpret_cast<LPICMP6CREATEFILE>(GetProcAddress(m_hIcmp, "Icmp6CreateFile"));
    m_pIcmpSendEcho = reinterpret_cast<LPICMPSENDECHO>(GetProcAddress(m_hIcmp, "IcmpSendEcho"));
    m_pIcmpCloseHandle = reinterpret_cast<LPICMPCLOSEHANDLE>(GetProcAddress(m_hIcmp, "IcmpCloseHandle"));
    m_pIcmp6SendEcho2 = reinterpret_cast<LPICMP6SENDECHO2>(GetProcAddress(m_hIcmp, "Icmp6SendEcho2"));
    m_pIcmpSendEcho2Ex = reinterpret_cast<LPICMPSENDECHO2EX>(GetProcAddress(m_hIcmp, "IcmpSendEcho2Ex"));

    if ((m_pIcmpCreateFile == NULL) || (m_pIcmpSendEcho == NULL) ||	(m_pIcmpCloseHandle == NULL))
    {
      ///ATLTRACE(_T("CPing::CPing, Could not find the required functions in the Iphlpapi dll, will try ICMP.dll\n"));

      FreeLibrary(m_hIcmp);
      m_hIcmp = NULL;
      m_pIcmpCreateFile = NULL; 
      m_pIcmpSendEcho = NULL;
      m_pIcmpCloseHandle = NULL;
      m_pIcmp6CreateFile = NULL;
      m_pIcmp6SendEcho2 = NULL;
      m_pIcmpSendEcho2Ex = NULL;
    }
  }

  if (m_hIcmp == NULL)
  {
    ///ATLTRACE(_T("CPing::CPing, Falling back to trying ICMP DLL\n"));

    //If not fall back to using the ICMP library
    m_hIcmp = LoadLibraryFromSystem32(_T("ICMP.DLL"));
    if (m_hIcmp != NULL)
    {
      //Retrieve pointers to the functions in the ICMP dll
      m_pIcmpCreateFile = reinterpret_cast<LPICMPCREATEFILE>(GetProcAddress(m_hIcmp, "IcmpCreateFile"));
      m_pIcmpSendEcho = reinterpret_cast<LPICMPSENDECHO>(GetProcAddress(m_hIcmp, "IcmpSendEcho"));
      m_pIcmpCloseHandle = reinterpret_cast<LPICMPCLOSEHANDLE>(GetProcAddress(m_hIcmp, "IcmpCloseHandle"));

      if ((m_pIcmpCreateFile == NULL) || (m_pIcmpSendEcho == NULL) ||	(m_pIcmpCloseHandle == NULL))
      {
        ///ATLTRACE(_T("CPing::CPing, Could not find the required functions in the ICMP DLL\n"));

        FreeLibrary(m_hIcmp);
        m_hIcmp = NULL;
        m_pIcmpCreateFile = NULL; 
        m_pIcmpSendEcho = NULL;
        m_pIcmpCloseHandle = NULL;
      }
    }
    else
    {
     /// ATLTRACE(_T("CPing::CPing, Could not load up the ICMP DLL\n"));
    }
  }
}

CPing::~CPing()
{
  if (m_hIcmp != NULL)
  {
    FreeLibrary(m_hIcmp);
    m_hIcmp = NULL;
  }
}

//Fill up the ICMP packet with defined values
void CPing::FillIcmpData(_Out_writes_bytes_(dwRequestSize) BYTE* pRequestData, _In_ DWORD dwRequestSize) const
{
  memset(pRequestData, 'E', dwRequestSize);
}

HMODULE CPing::LoadLibraryFromSystem32(_In_ LPCTSTR lpFileName)
{
  //Get the Windows System32 directory
  TCHAR szFullPath[_MAX_PATH];
  szFullPath[0] = _T('\0');
  if (GetSystemDirectory(szFullPath, _countof(szFullPath)) == 0)
    return NULL;

  //Setup the full path and delegate to LoadLibrary    
#pragma warning(suppress: 6102) //There is a bug with the SAL annotation of GetSystemDirectory in the Windows 8.1 SDK
  _tcscat_s(szFullPath, _countof(szFullPath), _T("\\"));
  _tcscat_s(szFullPath, _countof(szFullPath), lpFileName);
  return LoadLibrary(szFullPath);
}

BOOL CPing::PingUsingICMPv4(_In_ LPCTSTR pszHostName, _Inout_ CPingReplyv4& pr, _In_ UCHAR nTTL, _In_ DWORD dwTimeout, _In_ WORD wDataSize, _In_ UCHAR nTOS, _In_ BOOL bDontFragment, _In_ BOOL bFlagReverse, _In_opt_ LPCTSTR pszLocalBoundAddress) const
{
  //Do the address lookup
  ATL::CSocketAddr lookup;
  int nError = lookup.FindAddr(pszHostName, 0, 0, AF_INET, 0, 0);
  if (nError != 0)
  {
    ///ATLTRACE(_T("CPing::PingUsingICMPv4, Failed to do address lookup\n"));
    SetLastError(nError);
    return FALSE;
  }

  //Note we always use the first address returned from ATL::CSocketAddr::FindAddr. If you want to use a different
  //Address then do the lookup yourself and pass in the correct value in the "pszHostName" parameter
  const ADDRINFOT* pAddress = lookup.GetAddrInfoList();
  ATLASSUME(pAddress != NULL);
  ATLASSERT(pAddress->ai_family == AF_INET);
  sockaddr_in* pDestAddress = reinterpret_cast<sockaddr_in*>(pAddress->ai_addr);

  //Create the ICMP handle
  HANDLE hIP = NULL;
  if ((m_pIcmpCreateFile == NULL) || (m_pIcmpCloseHandle == NULL))
  {
    ///ATLTRACE(_T("CPing::PingUsingICMPv4, IcmpCreateFile and IcmpCloseHandle functions are not available\n"));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
  }
  hIP = m_pIcmpCreateFile();
  if (hIP == INVALID_HANDLE_VALUE)
  {
    ///ATLTRACE(_T("CPing::PingUsingICMPv4, Could not get a valid IPv4 ICMP handle\n"));
    return FALSE;
  }

  //Set up the option info structure
  IP_OPTION_INFORMATION OptionInfo;
  memset(&OptionInfo, 0, sizeof(OptionInfo));
  OptionInfo.Ttl = nTTL;
  OptionInfo.Tos = nTOS;
  if (bDontFragment)
    OptionInfo.Flags = IP_FLAG_DF;
  if (bFlagReverse)
    OptionInfo.Flags |= IP_FLAG_REVERSE;

  //Set up the data which will be sent
  ATL::CHeapPtr<BYTE> sendBuf;
  if (!sendBuf.Allocate(wDataSize))
  {
    ATLASSERT(m_pIcmpCloseHandle != NULL);
    m_pIcmpCloseHandle(hIP);
    ///ATLTRACE(_T("CPing::PingUsingICMPv4, Failed to allocate send buffer\n"));
    SetLastError(ERROR_OUTOFMEMORY);
    return FALSE;
  }
  FillIcmpData(sendBuf.m_pData, wDataSize);

  //Do the actual Ping
  DWORD dwReplySize = sizeof(ICMP_ECHO_REPLY) + wDataSize + 8;
  if (pr.Reply.m_pData != NULL)
    pr.Reply.Free();
  if (!pr.Reply.Allocate(dwReplySize))
  {
    ATLASSERT(m_pIcmpCloseHandle != NULL);
    m_pIcmpCloseHandle(hIP);
    ///ATLTRACE(_T("CPing::PingUsingICMPv4, Failed to allocate reply buffer\n"));
    SetLastError(ERROR_OUTOFMEMORY);
    return FALSE;
  }

  //Bind to the local address if need be
  IPAddr srcAddress = 0;
  BOOL bBindSourceIPAddress = FALSE;
  if (pszLocalBoundAddress && _tcslen(pszLocalBoundAddress))
  {
    bBindSourceIPAddress = TRUE;
    if (m_pIcmpSendEcho2Ex == NULL)
    {
      ATLASSERT(m_pIcmpCloseHandle != NULL);
      m_pIcmpCloseHandle(hIP);
     /// ATLTRACE(_T("CPing::PingUsingICMPv4, IcmpSendEcho2Ex function is not available\n"));
      SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
      return FALSE;
    }
    nError = lookup.FindAddr(pszLocalBoundAddress, 0, AI_PASSIVE, AF_INET, 0, 0);
    if (nError != 0)
    {
      ATLASSERT(m_pIcmpCloseHandle != NULL);
      m_pIcmpCloseHandle(hIP);
     /// ATLTRACE(_T("CPing::PingUsingICMPv4, Failed to lookup local address to bind to\n"));
      SetLastError(nError);
      return FALSE;
    }

    pAddress = lookup.GetAddrInfoList();
    ATLASSUME(pAddress != NULL);
    ATLASSERT(pAddress->ai_family == AF_INET);
    sockaddr_in* pLookupAddress = reinterpret_cast<sockaddr_in*>(pAddress->ai_addr);
    srcAddress = pLookupAddress->sin_addr.S_un.S_addr;
  }
  else
  {
    if (m_pIcmpSendEcho == NULL)
    {
      ATLASSERT(m_pIcmpCloseHandle != NULL);
      m_pIcmpCloseHandle(hIP);
    ///  ATLTRACE(_T("CPing::PingUsingICMPv4, IcmpSendEcho function is not available\n"));
      SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
      return FALSE;
    }
  }

  DWORD dwRecvPackets = bBindSourceIPAddress ? m_pIcmpSendEcho2Ex(hIP, NULL, NULL, NULL, srcAddress, pDestAddress->sin_addr.S_un.S_addr, sendBuf.m_pData, wDataSize, &OptionInfo, pr.Reply.m_pData, dwReplySize, dwTimeout) :
                                               m_pIcmpSendEcho(hIP, pDestAddress->sin_addr.S_un.S_addr, sendBuf.m_pData, wDataSize, &OptionInfo, pr.Reply.m_pData, dwReplySize, dwTimeout);

  //Check we got the packet back
  BOOL bSuccess = (dwRecvPackets == 1);

  //Close the ICMP handle
  ATLASSERT(m_pIcmpCloseHandle != NULL);
  m_pIcmpCloseHandle(hIP);

  if (bSuccess)
  {
    //Ping was successful, copy over the pertinent info into the return structure
    memset(&pr.Address, 0, sizeof(sockaddr_in));
    pr.Address.sin_family = AF_INET;
    const ICMP_ECHO_REPLY* pEchoReply = pr.GetICMP_ECHO_REPLY();
    pr.Address.sin_addr.S_un.S_addr = pEchoReply->Address;
    pr.RTT = pEchoReply->RoundTripTime;
    pr.EchoReplyStatus = pEchoReply->Status;
  }

  //return the status
  return bSuccess; 
}

BOOL CPing::PingUsingICMPv6(_In_ LPCTSTR pszHostName, _Inout_ CPingReplyv6& pr, _In_ UCHAR nTTL, _In_ DWORD dwTimeout, _In_ WORD wDataSize, _In_ UCHAR nTOS, _In_ BOOL bDontFragment, _In_ BOOL bFlagReverse, _In_opt_ LPCTSTR pszLocalBoundAddress) const
{
  //Do the address lookup
  ATL::CSocketAddr lookup;
  int nError = lookup.FindAddr(pszHostName, 0, 0, AF_INET6, 0, 0);
  if (nError != 0)
  {
    ///ATLTRACE(_T("CPing::PingUsingICMPv6, Failed to do address lookup\n"));
    SetLastError(nError);
    return FALSE;
  }

  //Note we always use the first address returned from ATL::CSocketAddr::FindAddr. If you want to use a different
  //Address then do the lookup yourself and pass in the correct value in the "pszHostName" parameter
  const ADDRINFOT* pAddress = lookup.GetAddrInfoList();
  ATLASSUME(pAddress != NULL);
  ATLASSERT(pAddress->ai_family == AF_INET6);
  sockaddr_in6* pDestAddress = reinterpret_cast<sockaddr_in6*>(pAddress->ai_addr);

  //Create the ICMP handle
  HANDLE hIP = NULL;
  if ((m_pIcmp6CreateFile == NULL) || (m_pIcmp6SendEcho2 == NULL) || (m_pIcmpCloseHandle == NULL))
  {
    ///ATLTRACE(_T("CPing::PingUsingICMPv6, Icmp6CreateFile, Icmp6SendEcho2 and IcmpCloseHandle functions are not available\n"));
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
  }
  hIP = m_pIcmp6CreateFile();
  if (hIP == INVALID_HANDLE_VALUE)
  {
   /// ATLTRACE(_T("CPing::PingUsingICMPv6, Could not get a valid IPv6 ICMP handle\n"));
    return FALSE;
  }

  //Set up the option info structure
  IP_OPTION_INFORMATION OptionInfo;
  memset(&OptionInfo, 0, sizeof(OptionInfo));
  OptionInfo.Ttl = nTTL;
  OptionInfo.Tos = nTOS;
  if (bDontFragment)
    OptionInfo.Flags = IP_FLAG_DF;
  if (bFlagReverse)
    OptionInfo.Flags |= IP_FLAG_REVERSE;

  //Set up the data which will be sent
  ATL::CHeapPtr<BYTE> sendBuf;
  if (!sendBuf.Allocate(wDataSize))
  {
    ATLASSERT(m_pIcmpCloseHandle != NULL);
    m_pIcmpCloseHandle(hIP);
  ///  ATLTRACE(_T("CPing::PingUsingICMPv6, Failed to allocate send buffer\n"));
    SetLastError(ERROR_OUTOFMEMORY);
    return FALSE;
  }
  FillIcmpData(sendBuf.m_pData, wDataSize);

  //Do the actual Ping
  DWORD dwReplySize = sizeof(ICMPV6_ECHO_REPLY) + wDataSize + 8;
  if (pr.Reply.m_pData != NULL)
    pr.Reply.Free();
  if (!pr.Reply.Allocate(dwReplySize))
  {
    ATLASSERT(m_pIcmpCloseHandle != NULL);
    m_pIcmpCloseHandle(hIP);
   /// ATLTRACE(_T("CPing::PingUsingICMPv6, Failed to allocate reply buffer\n"));
    SetLastError(ERROR_OUTOFMEMORY);
    return FALSE;
  }

  //Bind to the local address if need be
  sockaddr_in6 srcAddress;
  memset(&srcAddress, 0, sizeof(srcAddress));
  srcAddress.sin6_family = AF_INET6;
  if (pszLocalBoundAddress && _tcslen(pszLocalBoundAddress))
  {
    nError = lookup.FindAddr(pszLocalBoundAddress, 0, AI_PASSIVE, AF_INET6, 0, 0);
    if (nError != 0)
    {
      ATLASSERT(m_pIcmpCloseHandle != NULL);
      m_pIcmpCloseHandle(hIP);
  ///    ATLTRACE(_T("CPing::PingUsingICMPv6, Failed to lookup local address to bind to\n"));
      SetLastError(nError);
      return FALSE;
    }

    pAddress = lookup.GetAddrInfoList();
    ATLASSUME(pAddress != NULL);
    ATLASSERT(pAddress->ai_family == AF_INET6);
    sockaddr_in6* pLookupAddress = reinterpret_cast<sockaddr_in6*>(pAddress->ai_addr);
    srcAddress.sin6_port = pLookupAddress->sin6_port;
    srcAddress.sin6_flowinfo = pLookupAddress->sin6_flowinfo;
    memcpy_s(&srcAddress.sin6_addr, sizeof(srcAddress.sin6_addr), &pLookupAddress->sin6_addr, sizeof(pLookupAddress->sin6_addr));
    srcAddress.sin6_scope_id = pLookupAddress->sin6_scope_id;
  }
  else
    srcAddress.sin6_addr = in6addr_any;

  DWORD dwRecvPackets = m_pIcmp6SendEcho2(hIP, NULL, NULL, NULL, &srcAddress, pDestAddress, sendBuf.m_pData, wDataSize, &OptionInfo, pr.Reply.m_pData, dwReplySize, dwTimeout);

  //Check we got the packet back
  BOOL bSuccess = (dwRecvPackets == 1);

  //Close the ICMP handle
  ATLASSERT(m_pIcmpCloseHandle != NULL);
  m_pIcmpCloseHandle(hIP);

  if (bSuccess)
  {
    //Ping was successful, copy over the pertinent info into the return structure
    memset(&pr.Address, 0, sizeof(sockaddr_in6));
    pr.Address.sin6_family = AF_INET6;
    const ICMPV6_ECHO_REPLY* pEchoReply = pr.GetICMPV6_ECHO_REPLY();
    pr.Address.sin6_port = pEchoReply->Address.sin6_port;
    pr.Address.sin6_flowinfo = pEchoReply->Address.sin6_flowinfo;
    memcpy_s(&pr.Address.sin6_addr, sizeof(pr.Address.sin6_addr), pEchoReply->Address.sin6_addr, sizeof(pEchoReply->Address.sin6_addr));
    pr.Address.sin6_scope_id = pEchoReply->Address.sin6_scope_id;
    pr.RTT = pEchoReply->RoundTripTime;
    pr.EchoReplyStatus = pEchoReply->Status;
  }

  //return the status
  return bSuccess;
}
